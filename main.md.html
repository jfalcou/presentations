<!------------------------------------------------------------------------------------------------->
<!--
  Copyright 2020 Joel Falcou
  Licensed under the terms of the Attribution-ShareAlike 4.0 International License (CC BY-SA 4.0)
-->
<!------------------------------------------------------------------------------------------------->

<meta charset="utf-8" lang="en">
<!------------------------------------------------------------------------------------------------->

**An Array of Problems**
    An Array of Solutions
<small><em><span class="current-date"></span></em></small>
<br>
Joel FALCOU
<br>
<small>
with a side of Jean-Thierry Lapresté, Vincent Reverdy and Jules Pénuchot.
</small>
<br>
<center><small>![](images/lri.jpg style="height: 3rem")&nbsp;&nbsp;&nbsp;![](images/codereckons.png style="height: 3rem")</small></center>
<center>![](images/ccby40.png style="height: 0.7rem")</center>
<small><small>Powered by Markdeep and Markdeep-Slides</small></small>

---
<!------------------------------------------------------------------------------------------------->

# Context

---

## Why do we even array ?

<div style="columns:2;-webkit-columns:2;-moz-columns:2;column-gap:3em;-webkit-column-gap:3em;-moz-column-gap:3em">

### Computations as a science pillar

  * Simulations replaced experiments
  * Fast computers are time machines
  * Users are mainly scientists though

### Enter the Matrix

  * A nD-array must be **fast**
  * A nD-array must be **easy to use**
  * A nD-array must be **expressive**
<br>

<center>
![](images/simulation_plasma.png style="height: 9rem")
</center>
</div>

<center>
!!! ERROR:
    How to design such a pervasive data structure ?
</center>

---

## Challenges

### A proper nD-array must be **fast**
  * Must be usable with modern hardware (SIMD, GPGPU, ...)
  * Abstractions should not hinder performances

### A proper nD-array must be **easy to use**
  * Must be intuitive for numeric-savvy users
  * Must protect users from performance anti-patterns

### A proper nD-array must be **expressive**
  * Numeric code should look numeric
  * Combination of expressions should evaluate intuitively

---

## Existing solutions

### View/container
  * `std::vector`/`std::array`
  * `std::span`
  * `std::mdspan`
  * `Boost.QVM`

### Expression-templates
  * `Blitz++`
  * `Eigen`
  * `Blaze`
  * `NT²`

---

## Why are those solutions not adequate ?

### Concerns are to be separated
  * Lazy evaluation
  * nD-array handling
  * Memory allocation
  * Hardware support

---

## Why are those solutions not adequate ?

### Concerns are to be separated
  * Lazy evaluation
  * nD-array handling
  * Memory allocation
  * Hardware support


!!! ERROR: Solve each issues in its own software component
    * Maximize re-usability
    * No Monolith effect

---

## Our Stance

### Concerns are to be separated
  * Lazy evaluation
      * **NuCOG** (see our CppCon 2019 talk)

  * nD-array handling
    * **Kiwaku** (to be released Q3 2020)

  * Memory allocation
    * **Kuai** (to be released Q3 2020)

  * Hardware support
      * SIMD: **E.V.E** (to be released Q3 2020)
      * Threading:  **Unnamed Parallel Library** (tba)

---

## Our Stance

### Concerns are to be separated
  * Lazy evaluation
      * **NuCOG** (see our CppCon 2019 talk)

!!! Tip: nD-array handling
    **Kiwaku**

  * Memory allocation
    * **Kuai** (to be released Q3 2020)

  * Hardware support
      * SIMD: **E.V.E** (to be released Q3 2020)
      * Threading:  **Unnamed Parallel Library** (tba)

---

## Overview

  * **Basic elements of nD arrays**
      * Notion of shape
      * Notion of stride
      * Notion of storage order

  * **Flavor or arrays**
      * View
      * Array
      * [ ] Sub-indexing API

  * **Processing nD Data**
      * [ ] Iterators or Ranges ?
      * [ ] nD-aware Algorithms

---

<br><br><br><br><br><br><br>
!!! ERROR: WARNING
    This talks contains traces of maths. Be careful if you are intolerant or allergic

---

<!------------------------------------------------------------------------------------------------->
# Basic elements of nD arrays

---

## First principles design

### Performances dictate that:
  * We mostly deals with numeric types or aggregates
  * We assume that reallocation are few and far between
  * Memory of an array must be globally contiguous to appease the **Cache Gods**
  * Please think of the kitten and don't do `std::vector<std::vector<...>>`

### Compile-time dictates that:
  * We want small type interfaces
  * We want to reuse memoized types as much as possible
  * We want to benefits from C++17/20 templates goodies (`if constexpr`, Concepts, `...`)

---

## Defining an array shape

### Context
  * Arrays gather data in a n-dimensional grid
  * The number of dimensions is supposed **known at compile time**
  * The number of elements along each dimension may vary
  * The number of elements along a given dimension may be known at compile time
  * The initial ordering of those sizes is **domain specific** and **arbitrary**

****************************************************************************************************
*                       Dimension 0 : 4 elements
*                      <----------------------->
*                   ^  .-----+-----+-----+-----+
*    Dimension 1 :  |  |  14 |  9  |  0  |  -1 |
*    3 elements     |  '-----+-----+-----+-----+
*                   |  |  4  |  0  | 10  |  7  |   -->  This is a 4 x 3 array
*                   |  '-----+-----+-----+-----+
*                   |  |  1  |  7  |  2  |  51 |
*                   v  '-----+-----+-----+-----+
****************************************************************************************************

---

## Defining an array shape

### Objectives
  * Define a type efficiently storing those informations
  * Must be compatible with mixed bag of runtime and compile-time data

### Classical version
<script type="preformatted">
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ linenumbers
template<std::ptrdiff_t... Dims> struct extent { /* array and/or tuple-like interface */ };

// Mark-up to specify a dynamic size along a given dimension
inline constexpr std::ptrdiff_t dynamic = -1;

extent<4,3> fixed_4x3;                // Compile-time known extent
extent<dynamic,dynamic> dynamic(4,3); // Runtime known extent

extent< dynamic,dynamic,dynamic,dynamic
      , dynamic,dynamic,dynamic,dynamic // Ughhhh
      > dyn8d;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</script>

---

## Defining an array extent

### Issues
  * Type interface is cringy for regular cases
    * No one wants to use `array<float,extent<dynamic,dynamic,dynamic>>`
    * No one should be forced to write lenghty type alias
  * Implementation may or may not be efficient

### Solution
  * If we want compile-time value, we already have **`constexpr`**
  * What if we just construct an `constexpr` shape and be done
  * Use the same type for both runtime and compile-time
  * All thanks to C++20 **Non Type Template Parameter**

---

## Non Type Template Parameter

### Definition
  * Template parameters can contain non-type parameters
  * Classic cases include integral types, enumerations
  * Less classic cases are pointers to functions or external linkage object, `nullptr`

### What can be NTTP in C++20 ?
  * All base classes and non-static data members are public and non-mutable
  * The types of all bases classes and non-static data members are structural types
  * Also includes possibly multi-dimensional array of such types.

---

## Non Type Template Parameter

### Example
<script type="preformatted">
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ linenumbers
struct color
{
  char r,g,b;
};

template<color c> struct pixel
{
  // Some pixel-y API
};

pixel<color<255,0,0>> bright_red;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</script>

---

## Array shapes as NTTP

### Main idea
  * Design a `shape` type only caring about runtime size storage
  * Make it usable as an NTTP
  * Provides helpers to smooth definition of array

### Proposed interface
<script type="preformatted">
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ linenumbers
array<float,_3D>             x;                   // Unitialized 3D array with dynamic size
array<float,_2D>             y( of_shape(4,3) );  // 2D array with dynamic size of 4x3
array<float,_4D(4,3,1,2)>    z;                   // 3D array with  static size of 4x3x1x2

array<float, extent[4]()[3]> a;                   // Unitialized 3D array with size of 4x?x3
array<float, extent[4]()[3]> b( _[1] = 6);        // 3D array with size of 4x6x3

constexpr auto               s = extent()();      // 2D dynamic extent
array<float, s[10]>          w;                   // Unitialized 3D array with size of ?x?x10
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</script>
---

## Let's build an array

### 1 Dimension case
  * Let $A$ be an array of $S_0$ elements
  * Let $B$ be the first valid index of $A$
  * Let $I$ be the index of any element of $A$ with $I \in [B, B+S_0[$
  * Then memory offset to any element is defined as $\alpha(I) = I - B$

****************************************************************************************************
*             .----+----+----*----*----+----+----.
*  Addresses  | @0 | @1 | @2 | @3 | @4 | @5 | @6 |
*             '----+----+----*----*----+----+----'
*                               ^
*                               |  (B+3) - B = @(3)
*                               v
*             .----+----+----*----*----+----+----.
*  Indexes    | B  | B+1| B+2| B+3| B+4| B+5| B+6|
*             '----+----+----*----*----+----+----'
****************************************************************************************************

---

## Let's build an array

### 2 Dimensions case
  * Let $A$ be an array of $S_0 \times S_1$ elements
  * Let $(I_0,I_1)$ be the index of any element of $A$
  * $I_0 \in [B_0, B_0+S_0[, I_1 \in [B_1, B_1+S_1[$
  * $\alpha(I_0,I_1) = (I_0 - B_0) + S_0*(I_1-B_1)$

****************************************************************************************************
*
*           .-----+-----+-----+-----+
*  Indexes  |(1,0)|(2,0)|(3,0)|(4,0)|
*           '-----+-----*-----*-----+
*           |(1,1)|(2,1)|(3,1)|(4,1)|<---------+
*           '-----+-----*-----*-----+          |
*           |(1,2)|(2,2)|(3,2)|(4,2)|          |  ((3-1) + 4*(1-0)) = @(6)
*           '-----+-----+-----+-----+          |
*                                              |
*             .----+----+----+----+----+----*----*----+----+----+----+----.
*  Addresses  | @0 | @1 | @2 | @3 | @4 | @5 | @6 | @7 | @8 | @9 | @10| @11|
*             '----+----+----+----+----+----*----*----+----+----+----+----'
****************************************************************************************************

---

## Let's build an array

### 2 Dimensions case
  * Let $A$ be an array of $S_0 \times S_1$ elements
  * Let $(I_0,I_1)$ be the index of any element of $A$
  * $I_0 \in [B_0, B_0+S_0[, I_1 \in [B_1, B_1+S_1[$
  * $\alpha(I_0,I_1) = (I_1 - B_1) + S_1*(I_0-B_0)$

****************************************************************************************************
*
*           .-----+-----+-----+-----+
*  Indexes  |(1,0)|(2,0)|(3,0)|(4,0)|
*           '-----+-----*-----*-----+
*           |(1,1)|(2,1)|(3,1)|(4,1)|<--------------+
*           '-----+-----*-----*-----+               |
*           |(1,2)|(2,2)|(3,2)|(4,2)|               |  ((1-0) + 3*(3-1)) = @(7)
*           '-----+-----+-----+-----+               |
*                                                   |
*             .----+----+----+----+----+----+----*----*----+----+----+----.
*  Addresses  | @0 | @1 | @2 | @3 | @4 | @5 | @6 | @7 | @8 | @9 | @10| @11|
*             '----+----+----+----+----+----+----*----*----+----+----+----'
****************************************************************************************************

---
## Let's build an array

### 2 Dimensions case
  * Let $A$ be an array of $S_0 \times S_1$ elements
  * Let $(I_0,I_1)$ be the index of any element of $A$
  * $I_0 \in [B_0, B_0+S_0[, I_1 \in [B_1, B_1+S_1[$
  * $\alpha(I_0,I_1) = (I_0 - B_0) + S_0*(I_1-B_1)$

### What do we notice ?
  * The ordering of **logical dimensions** is arbitrary
  * We still have said neither *row* nor *column*. How come ?
  * As soon as we have more than 1D, the notion of **dimension ordering** looks problematic

!!! ERROR:
    💢 Which order is right ? 💢

---

## Storage order

### Logical vs Physical dimensions
  * As of now, we expressed dimensions in a **logical** way
  * We need to decide how to order them **physically** in memory
  * We requires the definition of a **storage order**

### Storage order
  * Defines a **permutation** of logical dimensions
  * Specify which dimensions is actually **stored contiguously** in memory
  * The notion that `C` is row major and `FORTRAN` is column major is not what you think it means

!!! Tip: Conclusion
    The storage order of an array dimensions must be specified by the user

---
## Storage order

### Storage order is a permutation
  * Must be definable in a generic way w/r to number of dimensions
  * We decide the storage order is known at compile-time
  * Basic storage order can be provided

<script type="preformatted">
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ linenumbers
template<auto Permutation> struct storage_order
{
  template<int I>
  static inline constexpr auto value = Permutation(I);
};

inline constexpr
storage_order< [](auto d, auto) { return d; }> c_order = {};

inline constexpr
storage_order< [](auto d, auto) { return d>1 ? d : 1-d; }> fortran_order = {};
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</script>

---

## Let's build an array

### 3 Dimensions case
  * Let $A$ be an array of $S_0 \times S_1 \times S_2$ elements
  * Let $(I_0,I_1,I_2)$ be the index of any element of $A$
  * $I_0 \in [B_0, B_0+S_0[, I_1 \in [B_1, B_1+S_1[, I_2 \in [B_2, B_2+S_2[$
  * $\alpha(I_0,I_1,I_2) = (I_0 - B_0) + S_0*(I_1-B_1) + S_0*S_1(I_2-B_2)$

### What do we notice ?
  * There is an underlying recursive or repetitive pattern to index`=>`address translation
  * We need to find a way to compute this indexing efficiently

---

## Storage & Access

### Naive implementation

<script type="preformatted">
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ linenumbers
template<std::integral Size, std::integral I0>
auto linearize_index(Size const*, I0 i0) noexcept
{
  return i0;
}

template<std::integral Size, std::integral I0, std::integral... Is>
auto linearize_index(Size const* dims, I0 i0, Is... is) noexcept
{
  return i0 + *dims * indexes_to_address(dims++,is...);
}

template<std::integral Size, std::size_t NDims, std::integral... Is>
auto linearize_index(std::array<Size,NDims> const& dims, Is... is) noexcept
{
  return linearize_index(dims.data(),is...);
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</script>

---

## Storage & Access

### By the power of ALGEBRA!!!
  * Let $A$ be an array of $S_0 \times \ldots \times S_{N-1}$ elements
  * Let $(I_0,\ldots,I_{N-1})$ be the index of any element of $A$

\begin{equation}
\Phi(\{I_0,I_1,I_2\},\{S_0,S_1,S_2\}) = I_0 + S_0 \times I_1 + S_0 \times S_1 \times I_2
\end{equation}

  * This looks like a sum of product

\begin{equation}
\Phi(\{I_0,I_1,I_2\},\{S_0,S_1,S_2\}) = I_0 \times 1 + S_0 \times I_1 + S_0 \times S_1 \times I_2
\end{equation}

  * aka, a dot product

\begin{equation}
\Phi(\{I_0,I_1,I_2\},\{S_0,S_1,S_2\}) = \{I_0,I_1,I_2\} \cdot \{1,S_0,S_0 \times S_1\}
\end{equation}

  * The $\{1,S_0,S_0 \times S_1\}$ are the **stride** of the array

---

## Storage & Access

### Stride
  * Let $A$ be an array of $S_0 \times \ldots \times S_{N-1}$ elements
  * Its **strides** are defined as the cumulative product of its dimensions
  * In most cases, the first stride is equal to 1, we call them **unit strides**

### Proposed API
  * Strides are constructible directly from a shape
  * Strides needs to encode which values is known to be unit
  * Strides may be runtime, compile-time or both
  * We will reuse the same API than for shape

---

## Storage & Access

### Stride-based implementation

<script type="preformatted">
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ linenumbers
template<std::integral Size, std::size_t NDims>
auto linearize_index( std::array<Size,NDims> const& strides
                    , std::array<Size,NDims> const& indexes
                    ) noexcept
{
  return [&]<std::size_t... N>( std::index_sequence<N...> const& )
  {
    std::prtdiff_t i = 0;
    return (i + ... + (strides[N]*indexes[N]));
  }( std::make_index_sequence<NDims>{} );
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</script>

---
<!------------------------------------------------------------------------------------------------->
# Flavor or arrays

  ---

## Array, View ?

### View
  * Views wraps existing memory in a nD-array like interface
  * Designed to be as small as possible in 'resting position'
  * Never owns any memory

### Array
  * Arrays owns memory allocated via an allocator or on the stack
  * Wraps said memory in a nD-array like interface
  * Designed to be as small as possible in 'resting position'

### Two sides of a same coins
  * An Array is a View over the memory it owns
  * Defines an efficient View leads to efficient Arrays

---

## Options management

### Point on the situation
  * Extent is an option
  * Stride is dependent on Extent but could be an option
  * Storage order is an option
  * Later on, allocator could be an option

### Preventing the Policy Parameters Plight
  * Variadics templates
  * No set-order on options
  * Reconstruct a set of options from within
  * **Let's have a look ...**

---

## View

### Let's gather some options

<script type="preformatted">
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ linenumbers
template<typename Type, auto... Options>
struct view
{
  static constexpr auto all_settings    = settings(Options...);
  static constexpr auto shape_settings  = shape<options::shape(all_settings)>{};
  static constexpr auto stride_settings = options::stride(all_settings, shape_settings);

  static constexpr bool is_dynamic      = shape_settings.is_dynamic;
  static constexpr bool is_fully_static = shape_settings.is_fully_static;
};
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</script>

### Notes
  * See how each options is still a NTTP
  * The `options` namespace contains function to extract a given option via its tag
  * Options can be used as default of the next one

---

## View

### Compile-time issues
  * Improve compile-time by separating concerns of template parameters
  * Handling the memory depends only on `Type`
  * Handling the data access depends only on shape and strides

### Building a view like a LEGO
  * Use the **SCARY** techniques T.61: Do not over-parameterize members (SCARY)
  * Split the main class in small base class with less template parameters
  * Design a `view_span<Type>` to handle the memory
  * Design a `view_access<Shape, Stride>` to handle the data access

---

## View

### SCARY Implementation

<script type="preformatted">
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ linenumbers
template<typename Type, auto... Options>
struct  view
      : detail::view_access < shape<options::shape(settings(Options...))>{}
                            , options::stride ( settings(Options...)
                                              , shape<options::shape(settings(Options...))>{}
                                              )
                            >
      , detail::view_span<Type*>
{
  static constexpr auto all_settings    = settings(Options...);
  static constexpr auto shape_settings  = shape<options::shape(all_settings)>{};
  static constexpr auto stride_settings = options::stride(all_settings, shape_settings);

  // ...

  using span_base       = detail::view_span<Type*>;
  using access_base     = detail::view_access<shape_settings, stride_settings>;
};
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</script>

---

## View

### Internals of `view_span`
  * `view_span` is a simple wrapper aroudn a pointer
  * Supports changes of pointee
  * Natively supports pointers and pointers to const

### Internals of `view_access`
  * `view_access` wraps a Shape and a Stride
  * Centralize all index related computation
  * Provides the **`linearize`** function
  * Optimized via **`requires`** clauses
  * **Let's have a look**

---

## Array

### A trivial definition
  * Array owns memory
  * Memory can be dynamically allocated (via an `Allocator`)
  * Memory can live on the stack

### What do we need to add
  * Provide a wrapper around allocator bound memory
  * Provide a wrapper around automatic storage memory
  * Exploit the type and value of Shape to decide where the data live
  * **Let's have a look**

---

## Sub-indexing API

### Let's share the cake !
  * Extracting sub-views from array/view is a very common pattern
  * It should be easy to write
  * It should cost nothing (or almost nothing)

### A Good Model : Matlab
---

## Sub-indexing API

---

## Sub-indexing API

---

## Sub-indexing API

---

## Slices

---

## Slices

---

## Slices

---

<!------------------------------------------------------------------------------------------------->
# Processing nD Data

___

## Iterator model

---

## Iterator model

---

## Range model

---

## Range model

---


## nD-aware algorithms

---


## nD-aware algorithms

---

## nD-aware algorithms

---

<!------------------------------------------------------------------------------------------------->
# Conclusion

---

## What did we achieved ?

### nD array-like containers
  * Use a proper representation
  * Minimizes 'resting size'
  * Flexible API and type API
  * Sub-array come for free

### nD Algorithms
  * Recursive descent of dimensions as a basic skeleton
  * Demonstration of usability in simple scenarios
  * Code generation QoI

---

## What's next ?

### Features
  * Walkthrough adaptors
  * Interaction with E.V.E and Kuai
  * Benchmarks of more complex use cases

### Toward a Release
  * Works to be done on documentations
  * Release planned before the Falls

---

# Thanks for your attention !

<!------------------------------------------------------------------------------------------------->
<!-- Markdeep slides stuff -->
<script>
    markdeepSlidesOptions = {
        aspectRatio: 16 / 9,
        theme: 'reckons',
        fontSize: 22,
        diagramZoom: 1.0,
        totalSlideNumber: true,
        progressBar: true,
        breakOnHeadings: false,
        slideChangeHook: (oldSlide, newSlide) => {},
        modeChangeHook: (newMode) => {}
    };
</script>
<link rel="stylesheet" href="markdeep-slides/lib/markdeep-relative-sizes/1.09/relativize.css">
<link rel="stylesheet" href="markdeep-slides/markdeep-slides.css">
<script src="markdeep-slides/markdeep-slides.js"></script>

<!-- Markdeep stuff -->
<script>
    markdeepOptions = {
        tocStyle: 'none',
        detectMath: false,
        onLoad: function() {
            initSlides();
        }
    };
</script>
<style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style>
<script src="markdeep-slides/lib/markdeep/1.09/markdeep.min.js" charset="utf-8"></script>
<script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>
