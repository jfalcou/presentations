<!------------------------------------------------------------------------------------------------->
<!--
  Copyright 2020 Joel Falcou
  Licensed under the terms of the Attribution-ShareAlike 4.0 International License (CC BY-SA 4.0)
-->
<!------------------------------------------------------------------------------------------------->

<meta charset="utf-8" lang="en">
<!------------------------------------------------------------------------------------------------->

**An Array of Problems**
    An Array of Solutions

<small><em><span class="current-date"></span></em></small><br>
Joel FALCOU
<br>
<br>
<center><small>![](images/lri.jpg style="height: 3rem")&nbsp;&nbsp;&nbsp;![](images/codereckons.png style="height: 3rem")</small></center>
<center>![](images/ccby40.png style="height: 0.7rem")</center>

---
<!------------------------------------------------------------------------------------------------->

# Context

---

## Why do we even array ?

<div style="columns:2;-webkit-columns:2;-moz-columns:2;column-gap:3em;-webkit-column-gap:3em;-moz-column-gap:3em">

### Computations as a science pillar

  * Simulations replaced experiments
  * Fast computers are time machines
  * Users are mainly scientists though

### Enter the Matrix

  * A nD-array must be **fast**
  * A nD-array must be **easy to use**
  * A nD-array must be **expressive**
<br>

<center>
![](images/simulation_plasma.png style="height: 9rem")
</center>
</div>

<center>
!!! ERROR:
    How to design such a pervasive data structure ?
</center>

---

## Challenges

### A proper nD-array must be **fast**
  * Must be usable with modern hardware (SIMD, GPGPU, ...)
  * Abstractions should not hinder performances

### A proper nD-array must be **easy to use**
  * Must be intuitive for numeric-savvy users
  * Must protect user from performance anti-patterns

### A proper nD-array must be **expressive**
  * Numeric code should look numeric
  * Combination of expressions should evaluates intuitively

---

## Existing solutions

### View/container
  * `std::vector`/`std::array`
  * `std::span`
  * `std::mdspan`
  * `Boost.QVM`

### Expression-templates
  * `Blitz++`
  * `Eigen`
  * `Blaze`
  * `NTÂ²`

---

## Why are those solutions not adequate ?

### Concerns are to be separated
  * Lazy evaluation
  * nD-array handling
  * Memory allocation
  * Hardware support

---

## Why are those solutions not adequate ?

### Concerns are to be separated
  * Lazy evaluation
  * nD-array handling
  * Memory allocation
  * Hardware support


!!! ERROR: Solve each issues in its own software component
    * Maximize re-usability
    * No Monolith effect

---

## Our Stance

### Concerns are to be separated
  * Lazy evaluation
      * **NuCOG** (see our CppCon 2019 talk)

  * nD-array handling
    * **Kiwaku** (to be released Q3 2020)

  * Memory allocation
    * **Kuai** (to be released Q3 2020)

  * Hardware support
      * SIMD: **E.V.E** (to be released Q3 2020)
      * Threading:  **Unnamed Parallel Library** (tba)

---

## Our Stance

### Concerns are to be separated
  * Lazy evaluation
      * **NuCOG** (see our CppCon 2019 talk)

!!! Tip: nD-array handling
    **Kiwaku**

  * Memory allocation
    * **Kuai** (to be released Q3 2020)

  * Hardware support
      * SIMD: **E.V.E** (to be released Q3 2020)
      * Threading:  **Unnamed Parallel Library** (tba)

---

## Overview

  * Basic elements of nD arrays
      * Notion of shape and stride
      * Notion of storage order
      * Options combination

  * Flavor or arrays
      * [ ] View
      * [ ] Array
      * [ ] Sub-indexing API
      * [ ] Slice

  * Processing nD Data
      * [ ] Iterators or Ranges ?
      * [ ] View based algorithms
      * [ ]   Work in progress

---
<!------------------------------------------------------------------------------------------------->
# Basic elements of nD arrays

---

## First principles design

### Performances dictate that:
  * We mostly deals with numeric types or aggregates
  * We assume that reallocation are few and far between
  * Memory of an array must be globally contiguous to appease the **Cache Gods**

### Compile-time dictates that:
  * We want small type interfaces
  * We want to reuse memoized types as much as possible
  * We want to benefits from C++17/20 templates goodies (`if constexpr`, concepts, `...`)

---

## Defining an array shape

### Context
  * Arrays gather data in a n-dimensional grid
  * The number of dimensions is supposed **known at compile time**
  * The number of elements along each dimension may vary
  * The number of elements along a given dimension may be known at compile time
  * The initial ordering of those sizes is **domain specific** and **arbitrary**

****************************************************************************************************
*                       Dimension 0 : 4 elements
*                      <----------------------->
*                   ^  .-----+-----+-----+-----+
*    Dimension 1 :  |  |  14 |  9  |  0  |  -1 |
*    3 elements     |  '-----+-----+-----+-----+
*                   |  |  4  |  0  | 10  |  7  |   -->  This is a 4 x 3 array
*                   |  '-----+-----+-----+-----+
*                   |  |  1  |  7  |  2  |  51 |
*                   v  '-----+-----+-----+-----+
****************************************************************************************************

---

## Defining an array shape

### Objectives
  * Define a type efficiently storing those informations
  * Must be compatible with mixed bag of runtime and compile-time data

### Classical version
<script type="preformatted">
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ linenumbers
template<std::ptrdiff_t... Dims> struct shape { /* array and/or tuple-like interface */ };

// Mark-up to specify a dynamic size along a given dimension
inline constexpr std::ptrdiff_t dynamic = -1;

shape<4,3> fixed_4x3;                // Compile-time known shape
shape<dynamic,dynamic> dynamic(4,3); // Runtime known shape

shape< dynamic,dynamic,dynamic,dynamic
      , dynamic,dynamic,dynamic,dynamic // Ughhhh
      > dyn8d;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</script>

---

## Defining an array shape

### Issues
  * Type interface is cringy for regular cases
    * No one wants to use `array<float,shape<dynamic,dynamic,dynamic>>`
    * No one should be forced to write lenghty type alias
  * Implementation may or may not be efficient

### Solution
  * If we want compile-time value, we already have **`constexpr`**
  * What if we just construct `constexpr` expr and be done
  * Use the same type for both runtime and compile-time
  * All thanks to C++20 **Non Type Template Parameter**

---

## Non Type Template Parameter

### Definition
  * Template parameter can contains non-types parameter
  * Classic cases includes integral type, enumeration
  * Less classic cases are pointers to functions or external linkage object, `nullptr`
  * Accepted types were added in C++20

### What can be NTTP in C++20
  * All base classes and non-static data members are public and non-mutable
  * The types of all bases classes and non-static data members are structural types
  * Also includes possibly multi-dimensional array of such types.

---

## Non Type Template Parameter

### Example
<script type="preformatted">
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ linenumbers
struct color
{
  char r,g,b;
};

template<color c> struct pixel
{
  // Some pixel-y API
};

pixel<color<255,0,0>> bright_red;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</script>

---

## Array shapes as NTTP

### Main idea
  * Design an `shape` type only caring about storing runtime size
  * Make it usable as an NTTP
  * Provides helpers to smooth definition of array

### Proposed interface
<script type="preformatted">
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ linenumbers
array<float,_3D>          x;                 // Unitialized 3D array with dynamic size
array<float,_2D>          y( _2D(4,3) );     // 2D array with dynamic size of 4x3
array<float,_4D(4,3,1,2)> z;                 // 3D array with  static size of 4x3x1x2

array<float, extent[4]()[3]> a;              // Unitialized 3D array with size of 4x?x3
array<float, extent[4]()[3]> b( _[1] = 6);   // 3D array with size of 4x6x3

constexpr auto               s = extent()(); // 2D dynamic extent
array<float, s[10]>          w;              // Unitialized 3D array with size of ?x?x10
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</script>
---

## Let's build an array

### 1 Dimension case
  * Let $A$ be an array of $S_0$ elements
  * Let $I$ be the index of any element of $A$ with $I \in [B, B+S_0[$
  * Then memory offset to any element is defined as $\alpha(I) = I - B$

****************************************************************************************************
*             .----+----+----*----*----+----+----.
*  Addresses  | @0 | @1 | @2 | @3 | @4 | @5 | @6 |
*             '----+----+----*----*----+----+----'
*                               ^
*                               |  (B+3) - B = @(3)
*                               v
*             .----+----+----*----*----+----+----.
*  Indexes    | B  | B+1| B+2| B+3| B+4| B+5| B+6|
*             '----+----+----*----*----+----+----'
****************************************************************************************************

---

## Let's build an array

### 2 Dimensions case
  * Let $A$ be an array of $S_0 \times S_1$ elements
  * Let $(I_0,I_1)$ be the index of any element of $A$
  * $I_0 \in [B_0, B_0+S_0[, I_1 \in [B_1, B_1+S_1[$
  * $\alpha(I_0,I_1) = (I_0 - B_0) + S_0*(I_1-B_1)$

****************************************************************************************************
*
*           .-----+-----+-----+-----+
*  Indexes  |(1,0)|(2,0)|(3,0)|(4,0)|
*           '-----+-----*-----*-----+
*           |(1,1)|(2,1)|(3,1)|(4,1)|<---------+
*           '-----+-----*-----*-----+          |
*           |(1,2)|(2,2)|(3,2)|(4,2)|          |  ((3-1) + 4*(1-0)) = @(6)
*           '-----+-----+-----+-----+          |
*                                              |
*             .----+----+----+----+----+----*----*----+----+----+----+----.
*  Addresses  | @0 | @1 | @2 | @3 | @4 | @5 | @6 | @7 | @8 | @9 | @10| @11|
*             '----+----+----+----+----+----*----*----+----+----+----+----'
****************************************************************************************************

---

## Let's build an array

### 2 Dimensions case
  * Let $A$ be an array of $S_0 \times S_1$ elements
  * Let $(I_0,I_1)$ be the index of any element of $A$
  * $I_0 \in [B_0, B_0+S_0[, I_1 \in [B_1, B_1+S_1[$
  * $\alpha(I_0,I_1) = (I_1 - B_1) + S_1*(I_0-B_0)$

****************************************************************************************************
*
*           .-----+-----+-----+-----+
*  Indexes  |(1,0)|(2,0)|(3,0)|(4,0)|
*           '-----+-----*-----*-----+
*           |(1,1)|(2,1)|(3,1)|(4,1)|<--------------+
*           '-----+-----*-----*-----+               |
*           |(1,2)|(2,2)|(3,2)|(4,2)|               |  ((1-0) + 3*(3-1)) = @(7)
*           '-----+-----+-----+-----+               |
*                                                   |
*             .----+----+----+----+----+----+----*----*----+----+----+----.
*  Addresses  | @0 | @1 | @2 | @3 | @4 | @5 | @6 | @7 | @8 | @9 | @10| @11|
*             '----+----+----+----+----+----+----*----*----+----+----+----'
****************************************************************************************************

---
## Let's build an array

### 2 Dimensions case
  * Let $A$ be an array of $S_0 \times S_1$ elements
  * Let $(I_0,I_1)$ be the index of any element of $A$
  * $I_0 \in [B_0, B_0+S_0[, I_1 \in [B_1, B_1+S_1[$
  * $\alpha(I_0,I_1) = (I_0 - B_0) + S_0*(I_1-B_1)$

### What do we notice ?
  * The ordering of **logical dimensions** is arbitrary
  * We still have said neither *row* nor *column*. How come ?
  * As soon as we have more than 1D, the notion of **dimension ordering** looks problematic

!!! ERROR:
    ðŸ’¢ Which order is right ? ðŸ’¢

---

## Storage order

### Logical vs Physical dimensions
  * As of now, we expressed dimensions in a **logical** way
  * We need to decide how to order them **physically** in memory
  * We requires the definition of a **storage order**

### Storage order
  * Defines a **permutation** of logical dimensions
  * Specify which dimensions is actually **stored contiguously** in memory
  * The notion that `C/C++` is row-major and `FORTRAN` is column major is a lie

!!! Tip: Conclusion
    The storage order of an array dimensions must be specified by the user

---

## Let's build an array

### 3 Dimensions case
  * Let $A$ be an array of $S_0 \times S_1 \times S_2$ elements
  * Let $(I_0,I_1,I_2)$ be the index of any element of $A$
  * $I_0 \in [B_0, B_0+S_0[, I_1 \in [B_1, B_1+S_1[, I_2 \in [B_2, B_2+S_2[$
  * $\alpha(I_0,I_1,I_2) = (I_0 - B_0) + S_0*(I_1-B_1) + S_0*S_1(I_2-B_2)$

### What do we notice ?
  * There is an underlying recursive or repetitive pattern to index`=>`address translation
  * We need to find a way to compute this indexing efficiently

---

## Storage & Access

### Naive implementation

<script type="preformatted">
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ linenumbers
template<std::integral Size, std::integral I0>
auto ita(Size const*, I0 i0) noexcept
{
  return i0;
}

template<std::integral Size, std::integral I0, std::integral... Is>
auto ita(Size const* dims, I0 i0, Is... is) noexcept
{
  return i0 + *dims * indexes_to_address(dims++,is...)
}

template<std::integral Size, std::size_t NDims, std::integral... Is>
auto ita(std::array<Size,NDims> const& dims, Is... is) noexcept
{
  return ita(dims.data(),is...)
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</script>

---

## Storage & Access

### By the power of ALGEBRA!!!
  * Let $A$ be an array of $S_0 \times \ldots \times S_{N-1}$ elements
  * Let $(I_0,\ldots,I_{N-1})$ be the index of any element of $A$

\begin{equation}
\Phi(\{I_0,I_1,I_2\},\{S_0,S_1,S_2\}) = I_0 + S_0 \times I_1 + + S_0 \times S_1 \times I_2
\end{equation}

  * This looks like a sum of product

\begin{equation}
\Phi(\{I_0,I_1,I_2\},\{S_0,S_1,S_2\}) = I_0 \times 1 + S_0 \times I_1 + + S_0 \times S_1 \times I_2
\end{equation}

  * aka, a dot product

\begin{equation}
\Phi(\{I_0,I_1,I_2\},\{S_0,S_1,S_2\}) = \{I_0,I_1,I_2\} \cdot \{1,S_0,S_0 \times S_1\}
\end{equation}

  * The $\{1,S_0,S_0 \times S_1\}$ are the **stride** of the array

---

## Storage & Access

### Stride
  * Let $A$ be an array of $S_0 \times \ldots \times S_{N-1}$ elements
  * Its **strides** is defined as the partial product of its dimensions
  * In most cases, the first stride is equal to 1, we call them **unit strides**

### Proposed API
  * Strides are constructible from a shape directly
  * Strides needs to encode if they're unit or not
  * Strides may be runtime, compile-time or both
  * We will reuse the same API then for shape

---

<!------------------------------------------------------------------------------------------------->
# Storage & Access

---
<!------------------------------------------------------------------------------------------------->
# Processing nD Data

---
<!------------------------------------------------------------------------------------------------->
# Conclusion

---

## What did we achieved ?

---

## What's next ?

---

# Thanks for your attention !

<!------------------------------------------------------------------------------------------------->
<!-- Markdeep slides stuff -->
<script>
    markdeepSlidesOptions = {
        aspectRatio: 16 / 9,
        theme: 'reckons',
        fontSize: 22,
        diagramZoom: 1.0,
        totalSlideNumber: true,
        progressBar: true,
        breakOnHeadings: false,
        slideChangeHook: (oldSlide, newSlide) => {},
        modeChangeHook: (newMode) => {}
    };
</script>
<link rel="stylesheet" href="markdeep-slides/lib/markdeep-relative-sizes/1.09/relativize.css">
<link rel="stylesheet" href="markdeep-slides/markdeep-slides.css">
<script src="markdeep-slides/markdeep-slides.js"></script>

<!-- Markdeep stuff -->
<script>
    markdeepOptions = {
        tocStyle: 'none',
        detectMath: false,
        onLoad: function() {
            initSlides();
        }
    };
</script>
<style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style>
<script src="markdeep-slides/lib/markdeep/1.09/markdeep.min.js" charset="utf-8"></script>
<script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>
