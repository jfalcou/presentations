<!------------------------------------------------------------------------------------------------->
<!--
  Copyright 2020 Joel Falcou
  Licensed under the terms of the Attribution-ShareAlike 4.0 International License (CC BY-SA 4.0)
-->
<!------------------------------------------------------------------------------------------------->

<meta charset="utf-8" lang="en">
<!------------------------------------------------------------------------------------------------->

**TAKING TEMPLATES ONE STEP FURTHER**
    WITH OPAQUES TYPES AND GENERIC NTTPS
<small><em><span class="current-date"></span></em></small>
<br>
<br>
Joel FALCOU - Vincent REVERDY
<br>
<center><small>![](images/lri.jpg style="height: 3rem")&nbsp;&nbsp;&nbsp;![](images/codereckons.png style="height: 3rem")</small></center>
<center>![](images/ccby40.png style="height: 0.7rem")</center>
<small><small>Powered by Markdeep and Markdeep-Slides</small></small>

---

# Some Context

---
<!------------------------------------------------------------------------------------------------->
<!--
  INTRODUCTION
-->
<!------------------------------------------------------------------------------------------------->

## Why do we even array ?

<div style="columns:2;-webkit-columns:2;-moz-columns:2;column-gap:3em;-webkit-column-gap:3em;-moz-column-gap:3em">

### Computations as a science pillar

  * Simulations replaced experiments
  * Fast computers are time machines
  * Users are mainly scientists though

### Enter the Matrix

  * A nD-array must be **fast**
  * A nD-array must be **easy to use**
  * A nD-array must be **expressive**
<br>

<center>
![](images/simulation_plasma.png style="height: 9rem")
</center>
</div>

<center>
!!! ERROR:
    How to design such a pervasive data structure ?
</center>

---

## Challenges

### A proper nD-array must be **fast**
  * Must be usable with modern hardware (SIMD, GPGPU, ...)
  * Abstractions should not hinder performances
  * Must protect users from performance anti-patterns

### A proper nD-array must be **easy to use**
  * Must be intuitive for numeric-savvy users
  * Must be customizable for power users

### A proper nD-array must be **expressive**
  * Numeric code should look numeric
  * Combination of expressions should evaluate intuitively

---

## Existing solutions

### View/container
  * `std::vector`/`std::array`
  * `Boost.QVM`
  * `std::span`
  * `std::mdspan`

### Expression-templates
  * `Blitz++`
  * `Eigen`
  * `NTÂ²`
  * `Armadillo`
  * `Blaze`

---

## Existing solutions

<center>
![](images/fight-club.jpg style="height: 20rem")
</center>

---

## Why are those solutions not adequate ?

### Concerns are to be separated
  * Lazy evaluation
  * nD-array handling
  * Customization protocols
  * Hardware support

---

## Why are those solutions not adequate ?

### Concerns are to be separated
  * Lazy evaluation
  * nD-array handling
  * Customization protocols
  * Hardware support


!!! ERROR: Solve each issue in its own software component
    * Maximize re-usability
    * No Monolith effect

---

## Why are those solutions not adequate ?

### Concerns are to be separated
  * Lazy evaluation
  * nD-array handling
  * Customization protocols
  * Hardware support

!!! ERROR: Solve each issue in its own software component
    * Maximize re-usability
    * No Monolith effect

<center>
  **Today we will care about the nD-array handling and customization issues**
</center>

---

## Why designing API is hard

### Exploiting Compile Time Information
  * Compilers need high-level information to enable high-quality optimization
  * Users must be able to pass such information directly from the source

### Source of Implementation Leaks
  * Untyped values as template parameters
  * Rigid template API that limits library's evolution and usability
  * Improper compile-time/runtime separation of concern

---

## Why designing API is hard

### Exploiting Compile Time Information
  * Compilers need high-level information to enable high-quality optimization
  * Users must be able to pass such information directly from the source

### Source of Implementation Leaks
  * Untyped values as template parameters
  * Rigid template API that limits library's evolution and usability
  * Improper compile-time/runtime separation of concern

###  Examples
  * `-1` as a dynamic size tag for **`std::span`**/**`std::mdspan`**
  * **<script type="preformatted">`Eigen::Matrix<typename Scalar, int Rows, int Cols>`</script>**
  * Passing allocator as type+value instead of pure value

---

## Back to Generative Programming

<center>
  ![](images/demral.png style="height: 20rem")
</center>

---

## First principles design

### Performances dictate that:
  * We mostly deals with numeric types or aggregates
  * We assume that reallocation are few and far between
  * Memory of an array must be globally contiguous to appease the **Cache Gods** [^kitten]
  * Memory footprints for empty/compile-time sized array must be minimal

### Usability dictates that:
  * We want to express as much optimization opportunities as possible
  * We want users to be able to do so without unnecessary hurdle
  * Ownership should be trivial to specify
  * We want to benefit from C++17/20 templates goodies (`if constexpr`, Concepts, `...`)


[^kitten]: Please think of the kitten and don't do `std::vector<std::vector<...>>`

---

## Layout of the talks

### Runtime components handling
  * Full runtime components should be handled at runtime
  * No need for type-based specification
  * **Our choice: Opaque types**

### Optimizations specifications:
  * Array and view behavior options must be trivial to setup
  * Users should have access to an intuitive option passing API
  * **Our choice: Keyword parameters**

### Compile-time/Runtime Barrier
  * Compile-time options must have a rich semantic
  * **Out choice : Non Type Template Parameters**

---

<!------------------------------------------------------------------------------------------------->
<!--
  PART 1 : OPAQUE TYPES
-->
<!------------------------------------------------------------------------------------------------->

# Tips #1 - Opaque Types

---

## Definition & classical implementation

### SECTION

---

## Opaque types for non-critical customization points

### SECTION

---

## Application: Allocators

### SECTION

---
<!------------------------------------------------------------------------------------------------->
<!--
  PART 2 : KEYWORD PARAMETERS
-->
<!------------------------------------------------------------------------------------------------->

# Tips #2 - Keyword Parameters

---

## Definition & classical implementation

### SECTION

---

## Keywords parameters as lightweight EDSL

### SECTION

---

## Application: Disambiguation of size/value constructors

### SECTION

---
<!------------------------------------------------------------------------------------------------->
<!--
  PART 3 : GENERIC NTTP
-->
<!------------------------------------------------------------------------------------------------->
# Tips #3 - Generic NTTP

---

## Definition & C++20 status

### SECTION

---

## Removing code duplication with NTTPs

### SECTION

---

## Defining an array shape

### Context
  * Arrays gather data in a n-dimensional grid
  * The number of effective dimensions is supposed **known at compile time**
  * The number of elements along each dimension may vary
  * The number of elements along a given dimension may be known at compile time
  * The initial ordering of those sizes is **domain specific** and **arbitrary**

****************************************************************************************************
*                       Dimension 0 : 4 elements
*                      <----------------------->
*                   ^  .-----+-----+-----+-----+
*    Dimension 1 :  |  |  14 |  9  |  0  |  -1 |
*    3 elements     |  '-----+-----+-----+-----+
*                   |  |  4  |  0  | 10  |  7  |   -->  This is a 4 x 3 array
*                   |  '-----+-----+-----+-----+
*                   |  |  1  |  7  |  2  |  51 |
*                   v  '-----+-----+-----+-----+
****************************************************************************************************

---

## Array shapes as NTTP

### Main idea
  * Design a `shape` type only caring about runtime size storage
  * Make it usable as an NTTP
  * Provides helpers to smooth definition of array

### Proposed interface
<script type="preformatted">
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ linenumbers
array<float,_3D>             x;                  // Uninitialized 3D array with dynamic size
array<float,_2D>             y( of_shape(4,3) ); // 2D array with dynamic size of 4x3
array<float,_4D(4,3,1,2)>    z;                  // 4D array with  static size of 4x3x1x2

array<float, extent[4]()[3]> a;                  // Uninitialized 3D array with size of 4x?x3
array<float, extent[4]()[3]> b( _[1] = 6 );      // 3D array with size of 4x6x3

constexpr auto               s = extent()();     // 2D dynamic extent
array<float, s[10]>          w;                  // Uninitialized 3D array with size of ?x?x10
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</script>

---

<!------------------------------------------------------------------------------------------------->
<!--
  PART 4 : CONCLUSION
-->
<!------------------------------------------------------------------------------------------------->

---

# Conclusion

---

## Summing up

### SECTION

---

# Thanks for your attention !

<!------------------------------------------------------------------------------------------------->
<!-- Markdeep slides stuff -->
<script>
    markdeepSlidesOptions = {
        aspectRatio: 16 / 9,
        theme: 'reckons',
        fontSize: 22,
        diagramZoom: 1.0,
        totalSlideNumber: true,
        progressBar: true,
        breakOnHeadings: false,
        slideChangeHook: (oldSlide, newSlide) => {},
        modeChangeHook: (newMode) => {}
    };
</script>
<link rel="stylesheet" href="markdeep-slides/lib/markdeep-relative-sizes/1.09/relativize.css">
<link rel="stylesheet" href="markdeep-slides/markdeep-slides.css">
<script src="markdeep-slides/markdeep-slides.js"></script>

<!-- Markdeep stuff -->
<script>
    markdeepOptions = {
        tocStyle: 'none',
        detectMath: false,
        onLoad: function() {
            initSlides();
        }
    };
</script>
<style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style>
<script src="markdeep-slides/lib/markdeep/1.09/markdeep.min.js" charset="utf-8"></script>
<script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>
