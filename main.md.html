<!------------------------------------------------------------------------------------------------->
<!--
  Copyright 2020 Joel Falcou
  Licensed under the terms of the Attribution-ShareAlike 4.0 International License (CC BY-SA 4.0)
-->
<!------------------------------------------------------------------------------------------------->

<meta charset="utf-8" lang="en">
<!------------------------------------------------------------------------------------------------->

**The future of computation**
    the C++ way
<small><em><span class="current-date"></span></em></small>
<br>
Joel FALCOU
<br>
<br>
<center><small>![](images/lri.jpg style="height: 3rem")&nbsp;&nbsp;&nbsp;![](images/codereckons.png style="height: 3rem")</small></center>
<center>![](images/ccby40.png style="height: 0.7rem")</center>
<small><small>Powered by Markdeep and Markdeep-Slides</small></small>

---
<!------------------------------------------------------------------------------------------------->

## The Paradigm Change in Science

<div style="columns:2;-webkit-columns:2;-moz-columns:2;column-gap:3em;-webkit-column-gap:3em;-moz-column-gap:3em">

### From Experiments to Simulations

  * Simulations are part of the **Scientific Method**
  * Scientific Computing is Faster Research

### The Parallel Hell

  * The Great Heat Wall
  * Heterogeneous systems are the norm
  * **The Free Lunch** is over
<br>
<br>
<br>

<center>
![](images/simulation_plasma.png style="height: 9rem")
</center>
</div>

<center>
!!! ERROR Computing is  a tool for scientist.
    The real challenge in HPC is solving the Expressiveness/Efficiency Conundrum
</center>

---

## The Great Gap

<center>
![](images/problematic.png style="height: 17rem")
</center>

<center>
!!! ERROR The Expressiveness/Efficiency Conundrum
    As parallel systems complexity grows, the expressiveness gap turns into an ocean
</center>

---

## But Why on Earth using C++ ?

### Objectives
  1. Be non-disruptive
  2. Domain driven optimizations
  3. Provide intuitive API for the user
  4. Support a wide architectural landscape
  5. Be efficient

### Which languages ?

---

## But Why on Earth using C++ ?

### Objectives
  1. Be non-disruptive
  2. Domain driven optimizations
  3. Provide intuitive API for the user
  4. Support a wide architectural landscape
  5. Be efficient

### Which languages ?
  1. Use FORTRAN, C++, Python
  2. Use C++, Python
  3. Use C++, Python
  4. Use FORTRAN, C++, C
  5. Use FORTRAN, C++, C

---

## But Why on Earth using C++ ?

### Objectives
  1. Be non-disruptive
  2. Domain driven optimizations
  3. Provide intuitive API for the user
  4. Support a wide architectural landscape
  5. Be efficient

### Which languages ?
  1. Use FORTRAN, **C++**, Python
  2. Use **C++**, Python
  3. Use **C++**, Python
  4. Use FORTRAN, **C++**, C
  5. Use FORTRAN, **C++**, C

---

## But Why on Earth using C++ ?

### A lively language
  * C++ started a new live after C++11
  * The momentum of C++14,17,20 is going strong
  * Errors of the past has been fixed
  * New tools emerged from academic and industrial use

### A structuring language
  * B. Stroustrup describes C++ as an infrastructure language
  * C++ is a library building languages

!!! TIP Libraries are languages
    We can solve the Conundrum by designing Libraries as Languages

---

<!------------------------------------------------------------------------------------------------->

# The Code Is Data!

---

## C++ Meta-programming - A Sorry State of Affairs

### C++ Code generation
  * Preprocessor based : Boost.PP, Chaos
  * External code generator : usually very business oriented
  * The Dreaded Meta-Programming

### Meta-programming in C++ 03
  * Rely on templates functions and classes
  * Embed type or code fragment into reusable components
  * Chant *Cthulhu R’lyeh wgah’nagl fhtagn* to get it working
  * Wait ages and ages and ages of compile-time

---

## A Problem of Perspective

### The Fundamental Errors of pre-C++14 TMP
  * Focus on type
  * Play around silly syntax
  * Low level abstractions

### What to do then ???
  * Focus on code fragment generation/assembly
  * **Meta-programming is automation of code writing**
  * Let's have a quick look at other languages

---

## Meta-programming with OCAML

### Embeds "code fragment" as object
  * Separate the meta-program from the generated code
  * Code is put in boxes and generated at will
  * Follow OCAML type system for type safety

### Three main tools:
  * Creation of code fragment via Brackets
  * Injection of code via Escape
  * Execution via Run

---

## Meta-programming with OCAML

### Sample meta-programming

<script type="preformatted">
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ scheme linenumbers
# let a = .< 1+2 >.;;
   -> val a : int code = .<1+2>.

# let b = .< 3 * .~a >.;;
   -> val b : int code = .< 3 *(1+2)>.

# let c = .!b;;
   -> val c : int = 9
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</script>

### Notes:
  * There is a thin syntax layer around code blocks
  * Code fragments have a type
  * Everything is a data

---

## Nu-Meta-programming with C++

### Potential translation in C++
  * Code fragment ==> lambda functions
  * Injection ==> inlined function calls
  * Code replication ==> variadic templates
  * Execution ==> Compilation

### Additional Support
  * Code fragment selection using `if constexpr`
  * Reinforced typing using Concepts and `requires`
  * Code computation performed via `constexpr` functions
  * Use NTTP to carry abstraction in the compile-time steps

---

## Nu-Meta-programming with C++

### Additional Support
  * Code fragment selection using `if constexpr`
  * Reinforced typing using Concepts and `requires`
  * Code computation performed via `constexpr` functions
  * Use NTTP to carry abstraction in the compile-time steps

### Sample Use Cases
  * Functions composition
  * Code unrolling
  * Iteration over tuple member  (Boost.Hana)
  * String parsing at compile-time (CTRE)

---

## Nu-Meta-programming with C++

### Compile-time replication of code

<script type="preformatted">
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ c++ linenumbers
struct range
{
  int base, end, count = end-base;
};

template<auto Range, typename Code> constexpr void constexpr_for(Code c)
{
  [&c]<int... N>( std::integer_sequence<int, N...> )
  {
    (c( std::integral_constant<int,Range.base+N>{} ), ...); // C++17 fold expression
  }( std::make_integer_sequence<int, Range.count>{});
}

constexpr_for<range(-5,+5)>( [](auto index)                 // C++20 NTTP
{
  std::cout << index << "\n";
});
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</script>

---

## Application

### Metaprogramming GEMV

****************************************************************************************************
*
*                          GEMV Throughput on AARCH64 ARM processor
*
*               |
*           15 -+-┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄
*               |
*               |
*           12 -+-        ▒    ▒    ▒                             ▉ OpenBLAS
*               |         ▒    ▒    ▒
*    GB/s   10 -+-┄┄┄┄┄┄┄┄▒┄┄┄▉▒┄┄┄▉▒┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄              ▒ C++14 TMP
*               |         ▒   ▉▒   ▉▒   ▉
*               |    ▒   ▉▒   ▉▒   ▉▒   ▉▒
*               |    ▒   ▉▒   ▉▒   ▉▒   ▉▒
*               |   ▉▒   ▉▒   ▉▒   ▉▒   ▉▒
*           5  -+-┄┄▉▒┄┄┄▉▒┄┄┄▉▒┄┄┄▉▒┄┄┄▉▒┄┄┄▉┄┄┄┄┄┄
*               |   ▉▒   ▉▒   ▉▒   ▉▒   ▉▒   ▉▒   ▉
*               |   ▉▒   ▉▒   ▉▒   ▉▒   ▉▒   ▉▒   ▉▒
*               |   ▉▒   ▉▒   ▉▒   ▉▒   ▉▒   ▉▒   ▉▒
*               |   ▉▒   ▉▒   ▉▒   ▉▒   ▉▒   ▉▒   ▉▒
*           0  -+---+----+----+----+----+----+----+---▶
*                   64  128  256  512  1024 2048 4096
*
*                              Vector size
*
****************************************************************************************************

---

<!------------------------------------------------------------------------------------------------->

# Languages as Libraries

---

## The Elusive Domain Specific Language

### Domain Specific Languages
  * Non-Turing complete declarative languages
  * Solve a single type of problems
  * Express **what** to do instead of **how** to do it
  * E.g: SQL, Make, Matlab, $\ldots$

### Embedded Domain Specific Languages (EDSL) [Abrahams 2004]
  * EDSLs are simply a libraries that meets the same criteria than a DSL
  * EDSLs live in a general purpose **host** language
  * Using **Meta-programming** is one way to design such libraries
  * More specifically, **Expressions Templates**


---

## Expression Templates

<div style="columns:2;-webkit-columns:2;-moz-columns:2;column-gap:3em;-webkit-column-gap:3em;-moz-column-gap:3em">

### Principles

  * Relies on extensive operator overloading
  * Carries semantic information around code fragment
  * Introduces DSLs without disrupting dev. chain

### Benefits

  * Generic implementation becomes self-aware of optimizations
  * API abstraction level is arbitrary high
  * Boilerplates reduced to acceptable level via tools
<br>
<br>
<br>
<br>

<center>
![](images/ast-edsl.png style="height: 13rem")
</center>
</div>

---

## Expression Templates

### EDSL shortcomings
  * Most EDSL terminals act as both storage and tree spawner
  * Most EDSL don't support sub-expression building in template contexts

### Implications
  * Issue with copy vs deep-copy of ASTs
  * AST traversal is complex
  * Compile-time are bad

### A Better Approach
  * DSL in which storage and expression are separated
  * Make symbolic expression first class citizen within the library
  * Support transformation of expressions

---

## Expression Templates

### EDSL for symbolic formula

<script type="preformatted">
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ c++ linenumbers
// Basic formula
auto f = 6.67408e-11 * x_*y_ / ( z_ * z_ );
auto g = 6.67408e-11 * $(mass1)*$(mass2) / ($(distance)*$(distance));

// Variable renaming - g, g2 and f are equivalent
auto g2 = f( x_ = $(mass1), y_ = $(mass2), z_ = $(distance));

// Partial evaluation - g_10 is still a formula
auto g_10 = g( $(distance) = 10. );

// Mix different formulas together - k requires 6 variables
auto k = g + f;

// Full evaluations
auto qx = g( $(mass1) = 3.5, $(distance) = 10., $(mass2) = 7.6);
auto rx = g_10( $(mass1) = 3.5, $(mass2) = 7.6);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</script>

---

## Expression Templates

### Literal Strings as EDSL API
  * Add arbitrary syntax to the language
  * Support any kind of API style
  * Have Greater interoperability with existing code
  * Can be syntaxically enforced by Concepts

<script type="preformatted">
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ c++ linenumbers
// Build an expression by CT parsing of LaTeX
auto f   = "\sqrt[3]{\frac{x^3+y^3}{2}}\vec{v}"_tex;

auto res = f(x_ = 4, y_ = real(8), v_ = vector({1, 2, 3, 4}));
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</script>

---

<!------------------------------------------------------------------------------------------------->
# Conclusion

---

## C++ as a HPC infrastructure language

### Don't write code, write code's generator
  * Complexity of hardware and specifications rise
  * One can't really write everything by hand
  * Meta-programming offers an alternative
  * **Automate code generation to eradicate complexity and errors**

### Explore, Be Creative
  * C++17+ TMP is very flexible
  * Type based EDSL are a valuable backbone
  * String based EDSL is a thing to pursue
  * Next: code generation via Introspection

---

# Thanks for your attention !

<!------------------------------------------------------------------------------------------------->
<!-- Markdeep slides stuff -->
<script>
    markdeepSlidesOptions = {
        aspectRatio: 16 / 9,
        theme: 'reckons',
        fontSize: 22,
        diagramZoom: 1.0,
        totalSlideNumber: true,
        progressBar: true,
        breakOnHeadings: false,
        slideChangeHook: (oldSlide, newSlide) => {},
        modeChangeHook: (newMode) => {}
    };
</script>
<link rel="stylesheet" href="markdeep-slides/lib/markdeep-relative-sizes/1.09/relativize.css">
<link rel="stylesheet" href="markdeep-slides/markdeep-slides.css">
<script src="markdeep-slides/markdeep-slides.js"></script>

<!-- Markdeep stuff -->
<script>
    markdeepOptions = {
        tocStyle: 'none',
        detectMath: false,
        onLoad: function() {
            initSlides();
        }
    };
</script>
<style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style>
<script src="markdeep-slides/lib/markdeep/1.09/markdeep.min.js" charset="utf-8"></script>
<script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>
