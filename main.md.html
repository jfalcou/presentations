<!------------------------------------------------------------------------------------------------->
<!--
  Copyright 2020 Joel Falcou
  Licensed under the terms of the Attribution-ShareAlike 4.0 International License (CC BY-SA 4.0)
-->
<!------------------------------------------------------------------------------------------------->

<meta charset="utf-8" lang="en">
<!------------------------------------------------------------------------------------------------->

**An Array of Problems**
    An Array of Solutions

<small><em><span class="current-date"></span></em></small><br>
Joel FALCOU
<br>
<br>
<center><small>![](images/lri.jpg style="height: 3rem")&nbsp;&nbsp;&nbsp;![](images/codereckons.png style="height: 3rem")</small></center>
<center>![](images/ccby40.png style="height: 0.7rem")</center>

---
<!------------------------------------------------------------------------------------------------->

# Context

---

## Why do we even array ?

<div style="columns:2;-webkit-columns:2;-moz-columns:2;column-gap:3em;-webkit-column-gap:3em;-moz-column-gap:3em">

### Computations as a science pillar

  * Simulations replaced experiments
  * Fast computers are time machines
  * Users are mainly scientists though

### Enter the Matrix

  * A nD-array must be **fast**
  * A nD-array must be **easy to use**
  * A nD-array must be **expressive**
<br>

<center>
![](images/simulation_plasma.png style="height: 9rem")
</center>
</div>

<center>
!!! ERROR:
    How to design such a pervasive data structure ?
</center>

---

## Challenges

### A proper nD-array must be **fast**
  * Must be usable with modern hardware (SIMD, GPGPU, ...)
  * Abstractions should not hinder performances

### A proper nD-array must be **easy to use**
  * Must be intuitive for numeric-savvy users
  * Must protect user from performance anti-patterns

### A proper nD-array must be **expressive**
  * Numeric code should look numeric
  * Combination of expressions should evaluates intuitively

---

## Existing solutions

### View/container
  * `std::vector`/`std::array`
  * `std::span`
  * `std::mdspan`
  * `Boost.QVM`

### Expression-templates
  * `Blitz++`
  * `Eigen`
  * `Blaze`
  * `NTÂ²`

---

## Why are those solutions not adequate ?

### Concerns are to be separated
  * Lazy evaluation
  * nD-array handling
  * Memory allocation
  * Hardware support

---

## Why are those solutions not adequate ?

### Concerns are to be separated
  * Lazy evaluation
  * nD-array handling
  * Memory allocation
  * Hardware support


!!! ERROR: Solve each issues in its own software component
    * Maximize re-usability
    * No Monolith effect

---

## Our Stance

### Concerns are to be separated
  * Lazy evaluation
      * **NuCOG** (see our CppCon 2019 talk)

  * nD-array handling
    * **Kiwaku** (to be released Q3 2020)

  * Memory allocation
    * **Kuai** (to be released Q3 2020)

  * Hardware support
      * SIMD: **E.V.E** (to be released Q3 2020)
      * Threading:  **Unnamed Parallel Library** (tba)

---

## Our Stance

### Concerns are to be separated
  * Lazy evaluation
      * **NuCOG** (see our CppCon 2019 talk)

!!! Tip: nD-array handling
    **Kiwaku**

  * Memory allocation
    * **Kuai** (to be released Q3 2020)

  * Hardware support
      * SIMD: **E.V.E** (to be released Q3 2020)
      * Threading:  **Unnamed Parallel Library** (tba)

---

## Overview

  * Basic elements of a nD array
      * What's a nD array ?
      * Storage options
      * Basic API

  * Storage & Access
      * Efficient indexing
      * Subviews

  * Processing nD Data
      * Iterators or Ranges ?
      * View-based algorithms

---
<!------------------------------------------------------------------------------------------------->
# Basic elements

---

## First principles design

### Performances dictate that:
  * We mostly deals with numeric types or aggregates
  * We assume that reallocation are few and far between
  * Memory of an array must be globally contiguous to appease the **Cache Gods**

### Compile-time dictates that:
  * We want small type interfaces
  * We want to reuse memoized types as much as possible
  * We want to benefits from C++17/20 templates goodies (`if constexpr`, concepts, `...`)

---

## Let's build an array

### 1 Dimension case
  * Let $A$ be an array of $S_0$ elements
  * Let $I$ be the index of any element of $A$ with $I \in [B, B+S_0[$
  * Then memory offset to any element is defined as $\alpha(I) = I - B$

!!! Tip:
    A 1D array is defined by its base address and its base index

****************************************************************************************************
*             .----+----+----*----*----+----+----.
*  Addresses  | @0 | @1 | @2 | @3 | @4 | @5 | @6 |
*             '----+----+----*----*----+----+----'
*                               ^
*                               |  (B+3) - B = @(3)
*                               v
*             .----+----+----*----*----+----+----.
*  Indexes    | B  | B+1| B+2| B+3| B+4| B+5| B+6|
*             '----+----+----*----*----+----+----'
****************************************************************************************************

---

## Let's build an array

### 2 Dimensions case
  * Let $A$ be an array of $S_0 \times S_1$ elements
  * Let $(I_0,I_1)$ be the index of any element of $A$
  * $I_0 \in [B_0, B_0+S_0[, I_1 \in [B_1, B_1+S_1[$
  * $\alpha(I_0,I_1) = (I_0 - B_0) + S_0*(I_1-B_1)$

****************************************************************************************************
*
*           .-----+-----+-----+-----+
*  Indexes  |(1,0)|(2,0)|(3,0)|(4,0)|
*           '-----+-----*-----*-----+
*           |(1,1)|(2,1)|(3,1)|(4,1)|<---------+
*           '-----+-----*-----*-----+          |
*           |(1,2)|(2,2)|(3,2)|(4,2)|          |  ((3-1) + 4*(1-0)) = @(6)
*           '-----+-----+-----+-----+          |
*                                              |
*             .----+----+----+----+----+----*----*----+----+----+----+----.
*  Addresses  | @0 | @1 | @2 | @3 | @4 | @5 | @6 | @7 | @8 | @9 | @10| @11|
*             '----+----+----+----+----+----*----*----+----+----+----+----'
****************************************************************************************************

---

## Let's build an array

### 2 Dimensions case
  * Let $A$ be an array of $S_0 \times S_1$ elements
  * Let $(I_0,I_1)$ be the index of any element of $A$
  * $I_0 \in [B_0, B_0+S_0[, I_1 \in [B_1, B_1+S_1[$
  * $\alpha(I_0,I_1) = (I_1 - B_1) + S_1*(I_0-B_0)$

****************************************************************************************************
*
*           .-----+-----+-----+-----+
*  Indexes  |(1,0)|(2,0)|(3,0)|(4,0)|
*           '-----+-----*-----*-----+
*           |(1,1)|(2,1)|(3,1)|(4,1)|<-----------------------------+
*           '-----+-----*-----*-----+                              |
*           |(1,2)|(2,2)|(3,2)|(4,2)|                              |  ((4-0) + 3*(3-1)) = @(10)
*           '-----+-----+-----+-----+                              |
*                                                                  |
*             .----+----+----+----+----+----+----+----+----+----*----*----.
*  Addresses  | @0 | @1 | @2 | @3 | @4 | @5 | @6 | @7 | @8 | @9 | @10| @11|
*             '----+----+----+----+----+----+----+----+----+----*----*----'
****************************************************************************************************

---
## Let's build an array

### 2 Dimensions case
  * Let $A$ be an array of $S_0 \times S_1$ elements
  * Let $(I_0,I_1)$ be the index of any element of $A$
  * $I_0 \in [B_0, B_0+S_0[, I_1 \in [B_1, B_1+S_1[$
  * $\alpha(I_0,I_1) = (I_0 - B_0) + S_0*(I_1-B_1)$

### What do we notice ?
  * The ordering of **logical dimensions** is arbitrary
  * We still have said neither *row* nor *column*. How come ?
  * As soon as we have more than 1D, the notion of **dimension ordering** looks problematic

!!! ERROR:
    Which order is right ?
    <br>
    ðŸ’¢ I just wanted an array ðŸ’¢

---

## Storage order

### Logical vs Physical dimensions
  * As of now, we expressed dimensions in a **logical** way
  * We need to decide how to order them **physically** in memory
  * We requires the definition of a **storage order**

### Storage order
  * Defines a **permutation** of logical dimensions
  * Specify which dimensions is actually **stored contiguously** in memory
  * The notion that `C/C++` is row-major and `FORTRAN` is column major is a lie

!!! Tip: Conclusion
    The storage order of an array dimensions must be specified by the user

---

## Let's build an array

### 3 Dimensions case
  * Let $A$ be an array of $S_0 \times S_1 \times S_2$ elements
  * Let $(I_0,I_1,I_2)$ be the index of any element of $A$
  * $I_0 \in [B_0, B_0+S_0[, I_1 \in [B_1, B_1+S_1[, I_2 \in [B_2, B_2+S_2[$
  * $\alpha(I_0,I_1,I_2) = (I_0 - B_0) + S_0*(I_1-B_1) + S_0*S_1(I_2-B_2)$

### What do we notice ?
  * There is an underlying recursive or repetitive pattern to index`=>`address translation
  * We need to find a way to compute this indexing efficiently

---

## Storage & Access

### Naive implementation

<script type="preformatted">
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ C++ linenumbers
template<std::integral Size, std::integral I0>
auto ita_impl(Size const*, I0 i0) noexcept
{
  return i0;
}

template<std::integral Size, std::integral I0, std::integral... Is>
auto ita_impl(Size const* dims, I0 i0, Is... is) noexcept
{
  return i0 + *dims * indexes_to_address(dims++,is...)
}

template<std::integral Size, std::size_t NDims, std::integral... Is>
auto ita(std::array<Size,NDims> const& dims, Is... is) noexcept
{
  return ita_impls(dims.data(),is...)
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</script>

---

## Storage & Access

### By the power of ALGEBRA!!!
  * Let $A$ be an array of $S_0 \times \ldots \times S_{N-1}$ elements
  * Let $(I_0,\ldots,I_{N-1})$ be the index of any element of $A$
  * Let assume base index are all 0s for slide space concerns

---

<!------------------------------------------------------------------------------------------------->
# Storage & Access

---
<!------------------------------------------------------------------------------------------------->
# Processing nD Data

---
<!------------------------------------------------------------------------------------------------->
# Conclusion

---

## What did we achieved ?

---

## What's next ?

---

# Thanks for your attention !

<!------------------------------------------------------------------------------------------------->
<!-- Markdeep slides stuff -->
<script>
    markdeepSlidesOptions = {
        aspectRatio: 16 / 9,
        theme: 'reckons',
        fontSize: 22,
        diagramZoom: 1.0,
        totalSlideNumber: true,
        progressBar: true,
        breakOnHeadings: false,
        slideChangeHook: (oldSlide, newSlide) => {},
        modeChangeHook: (newMode) => {}
    };
</script>
<link rel="stylesheet" href="markdeep-slides/lib/markdeep-relative-sizes/1.09/relativize.css">
<link rel="stylesheet" href="markdeep-slides/markdeep-slides.css">
<script src="markdeep-slides/markdeep-slides.js"></script>

<!-- Markdeep stuff -->
<script>
    markdeepOptions = {
        tocStyle: 'none',
        detectMath: false,
        onLoad: function() {
            initSlides();
        }
    };
</script>
<style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style>
<script src="markdeep-slides/lib/markdeep/1.09/markdeep.min.js" charset="utf-8"></script>
<script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>
